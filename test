#if 0

#include <png.h>

typedef struct
{
  FILE *fp;
  png_structp png_ptr;
  png_infop info_ptr;
  png_colorp palette;
  PRBool hadError;
} Context;

static void
error_func (png_structp png_ptr, png_const_charp message)
{
  Context *context = png_get_error_ptr (png_save_ptr);

  g_warning ("Error: %s\n", message);

  context->hadError = PR_TRUE;
}

static PRBool
init_Context (Context *aContext,
              const nsACString &aFilename,
	      const nsACString &aURL,
              const nsACString &aTitle)
{
  PRBool ok = PR_FALSE;

  aContext->hadError = PR_FALSE;

  /* open the file */
  aContext->fp = fopen (nsPromiseFlatCString (aFilename).get(), "wb");
  if (aContext->fp == NULL) return PR_FALSE;

  /* Create and initialize the png_struct with the desired error handler
   * functions.  If you want to use the default stderr and longjump method,
   * you can supply NULL for the last three parameters.  We also check that
   * the library version is compatible with the one used at compile time,
   * in case we are using dynamically linked libraries.  REQUIRED.
   */
  aContext->png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING,
					       (png_voidp) Context,
					       (png_error_ptr) error_func,
					       (png_error_ptr) warn_func);

  if (aContext->png_ptr == NULL)
    {
      fclose (aContext->fp);
      return PR_FALSE
   }

  /* Allocate/initialize the image information data.  REQUIRED */
  aContext->info_ptr = png_create_info_struct (aContext->png_ptr);
  if (aContext->info_ptr == NULL)
    {
      fclose (aContext->fp);
      png_destroy_write_struct(&aContext->png_ptr, png_infopp_NULL);
      return PR_FALSE;
   }

#if 0
  /* Set error handling.  REQUIRED if you aren't supplying your own
    * error handling functions in the png_create_write_struct() call.
    */
   if (setjmp(png_jmpbuf(png_ptr)))
   {
      /* If we get here, we had a problem reading the file */
      fclose(fp);
      png_destroy_write_struct(&png_ptr, &info_ptr);
      return (ERROR);
   }
#endif

  /* set up the output control if you are using standard C streams */
  png_init_io (aContext->png_ptr, aContext->fp);
  if (aContext->hadError) goto cleanup;

  /* Set the image information here.  Width and height are up to 2^31,
   * bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend on
   * the color_type selected. color_type is one of PNG_COLOR_TYPE_GRAY,
   * PNG_COLOR_TYPE_GRAY_ALPHA, PNG_COLOR_TYPE_PALETTE, PNG_COLOR_TYPE_RGB,
   * or PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either PNG_INTERLACE_NONE or
   * PNG_INTERLACE_ADAM7, and the compression_type and filter_type MUST
   * currently be PNG_COMPRESSION_TYPE_BASE and PNG_FILTER_TYPE_BASE. REQUIRED
   */
  png_set_IHDR (aContext->png_ptr, aContext->info_ptr, aWidth, aHeight, bit_depth,
		PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,
		PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
  if (aContext->hadError) goto cleanup;

#if 0
  /* set the palette if there is one.  REQUIRED for indexed-color images */
   palette = (png_colorp) png_malloc (aContext->png_ptr, PNG_MAX_PALETTE_LENGTH
             * png_sizeof (png_color));
   /* ... set palette colors ... */
   png_set_PLTE(png_ptr, info_ptr, palette, PNG_MAX_PALETTE_LENGTH);
   /* You must not free palette here, because png_set_PLTE only makes a link to
      the palette that you malloced.  Wait until you are about to destroy
      the png structure. */
#endif

  /* optional significant bit chunk */
  png_color_8p sig_bit;
#if 0
  /* if we are dealing with a grayscale image then */
  sig_bit.gray = true_bit_depth;
#endif
  /* otherwise, if we are dealing with a color image then */
  sig_bit.red = 8;
  sig_bit.green = 8;
  sig_bit.blue = 8;
  /* if the image has an alpha channel then */
  sig_bit.alpha = 0;
  png_set_sBIT (aContext->png_ptr, aContext->info_ptr, sig_bit);
  if (aContext->hadError) goto cleanup;

#if 0
  /* Optional gamma chunk is strongly suggested if you have any guess
   * as to the correct gamma of the image.
   */
  png_set_gAMA(png_ptr, info_ptr, gamma);
#endif

#if 0
FIXME
  /* Optionally write comments into the image */
  text_ptr[0].key = "Title";
  text_ptr[0].text = "Mona Lisa";
  text_ptr[0].compression = PNG_TEXT_COMPRESSION_NONE;
  text_ptr[1].key = "Author";
  text_ptr[1].text = "Leonardo DaVinci";
  text_ptr[1].compression = PNG_TEXT_COMPRESSION_NONE;
  text_ptr[2].key = "Description";
  text_ptr[2].text = "<long text>";
  text_ptr[2].compression = PNG_TEXT_COMPRESSION_zTXt;
#ifdef PNG_iTXt_SUPPORTED
  text_ptr[0].lang = NULL;
  text_ptr[1].lang = NULL;
  text_ptr[2].lang = NULL;
#endif
  png_set_text(png_ptr, info_ptr, text_ptr, 3);
#endif

  /* other optional chunks like cHRM, bKGD, tRNS, tIME, oFFs, pHYs, */
  /* note that if sRGB is present the gAMA and cHRM chunks must be ignored
   * on read and must be written in accordance with the sRGB profile */

  /* Write the file header information.  REQUIRED */
  png_write_info (aContext->png_ptr, aContext->info_ptr);
  if (aContext->hadError) goto cleanup;

  /* Once we write out the header, the compression type on the text
   * chunks gets changed to PNG_TEXT_COMPRESSION_NONE_WR or
   * PNG_TEXT_COMPRESSION_zTXt_WR, so it doesn't get written out again
   * at the end.
   */

#if 0
  /* set up the transformations you want.  Note that these are
   * all optional.  Only call them if you want them.
   */

  /* invert monochrome pixels */
   png_set_invert_mono(png_ptr);

   /* Shift the pixels up to a legal bit depth and fill in
    * as appropriate to correctly scale the image.
    */
   png_set_shift(png_ptr, &sig_bit);

   /* pack pixels into bytes */
   png_set_packing(png_ptr);

   /* swap location of alpha bytes from ARGB to RGBA */
   png_set_swap_alpha(png_ptr);
#endif

//FIXME FIXME: do I need this??

  /* Get rid of filler (OR ALPHA) bytes, pack XRGB/RGBX/ARGB/RGBA into
   * RGB (4 channels -> 3 channels). The second parameter is not used.
   */
  png_set_filler (aContext->png_ptr, 0, PNG_FILLER_BEFORE);
  if (aContext->hadError) goto cleanup;

#if 0
   /* flip BGR pixels to RGB */
   png_set_bgr(png_ptr);

   /* swap bytes of 16-bit files to most significant byte first */
   png_set_swap(png_ptr);

   /* swap bits of 1, 2, 4 bit packed pixel formats */
   png_set_packswap(png_ptr);

   /* turn on interlace handling if you are not using png_write_image() */
   if (interlacing)
      number_passes = png_set_interlace_handling(png_ptr);
   else
#endif
      number_passes = 1;

   /* The easiest way to write the image (you may have a different memory
    * layout, however, so choose what fits your needs best).  You need to
    * use the first method if you aren't handling interlacing yourself.
    */
   png_uint_32 k, height, width;
   png_byte image[height][width*bytes_per_pixel];
   png_bytep row_pointers[height];

   if (height > PNG_UINT_32_MAX/png_sizeof(png_bytep))
     png_error (png_ptr, "Image is too tall to process in memory");

   for (k = 0; k < height; k++)
     row_pointers[k] = image + k*width*bytes_per_pixel;

   /* One of the following output methods is REQUIRED */
#ifdef entire /* write out the entire image data in one call */
   png_write_image(png_ptr, row_pointers);

   /* the other way to write the image - deal with interlacing */

#else /* no_entire*/ /* write out the image data by one or more scanlines */
   /* The number of passes is either 1 for non-interlaced images,
    * or 7 for interlaced images.
    */
   for (pass = 0; pass < number_passes; pass++)
   {
      /* Write a few rows at a time. */
      png_write_rows(png_ptr, &row_pointers[first_row], number_of_rows);

      /* If you are only writing one row at a time, this works */
      for (y = 0; y < height; y++)
      {
         png_write_rows(png_ptr, &row_pointers[y], 1);
      }
   }
#endif /* no_entire *//* use only one output method */

   /* You can write optional chunks like tEXt, zTXt, and tIME at the end
    * as well.  Shouldn't be necessary in 1.1.0 and up as all the public
    * chunks are supported and you can use png_set_unknown_chunks() to
    * register unknown chunks into the info structure to be written out.
    */

   /* It is REQUIRED to call this to finish writing the rest of the file */
   png_write_end(png_ptr, info_ptr);
#endif /* hilevel */

#if 0
   /* If you png_malloced a palette, free it here (don't free info_ptr->palette,
      as recommended in versions 1.0.5m and earlier of this example; if
      libpng mallocs info_ptr->palette, libpng will free it).  If you
      allocated it with malloc() instead of png_malloc(), use free() instead
      of png_free(). */
   png_free(png_ptr, palette);
   palette=NULL;

   /* Similarly, if you png_malloced any data that you passed in with
      png_set_something(), such as a hist or trans array, free it here,
      when you can be sure that libpng is through with it. */
   png_free(png_ptr, trans);
   trans=NULL;
#endif

   /* clean up after the write, and free any memory allocated */
   png_destroy_write_struct(&png_ptr, &info_ptr);

   /* close the file */
   fclose(fp);

   /* that's it */
   return (OK);
}

#endif

